/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "can_packet.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void StdId_Initialize(StdId* pVal)
{
    *pVal = (StdId) 0;
}
#endif

 
flag StdId_IsConstraintValid(const StdId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 2047);
	*pErrCode = ret ? 0 : ERR_StdId;

	return ret;
}

flag StdId_Encode(const StdId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? StdId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 2047);
    }

	return ret;
}

flag StdId_Decode(StdId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 2047);
	*pErrCode = ret ? 0 : 268435457;

	return ret;
}

flag StdId_XER_Encode(const StdId* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? StdId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, "StdId", *pVal, pErrCode, 0);
    }

	return ret;
}

flag StdId_XER_Encode_aux(const StdId* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? StdId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, xmlTag, *pVal, pErrCode, 0);
    }

	return ret;
}

flag StdId_XER_Decode(StdId* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, "StdId", pVal, pErrCode);

	return ret;
}

flag StdId_XER_Decode_aux(StdId* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, xmlTag, pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ExtId_Initialize(ExtId* pVal)
{
    *pVal = (ExtId) 0;
}
#endif

 
flag ExtId_IsConstraintValid(const ExtId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ExtId;

	return ret;
}

flag ExtId_Encode(const ExtId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? ExtId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 2147483647LL);
    }

	return ret;
}

flag ExtId_Decode(ExtId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 2147483647LL);
	*pErrCode = ret ? 0 : 268435458;

	return ret;
}

flag ExtId_XER_Encode(const ExtId* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? ExtId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, "ExtId", *pVal, pErrCode, 0);
    }

	return ret;
}

flag ExtId_XER_Encode_aux(const ExtId* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? ExtId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, xmlTag, *pVal, pErrCode, 0);
    }

	return ret;
}

flag ExtId_XER_Decode(ExtId* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, "ExtId", pVal, pErrCode);

	return ret;
}

flag ExtId_XER_Decode_aux(ExtId* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, xmlTag, pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Id_Initialize(Id* pVal)
{
    *pVal = (Id) {
    .kind = stdId_PRESENT,
    .u = { .stdId = 0}
};
}
#endif

 
flag Id_IsConstraintValid(const Id* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case stdId_PRESENT :
	        ret = StdId_IsConstraintValid(&pVal->u.stdId, pErrCode);
	        break;
	    case extId_PRESENT :
	        ret = ExtId_IsConstraintValid(&pVal->u.extId, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag Id_Encode(const Id* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Id_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case stdId_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = StdId_Encode(&pVal->u.stdId, pBitStrm, pErrCode, FALSE);
	    	break;
	    case extId_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = ExtId_Encode(&pVal->u.extId, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag Id_Decode(Id* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435459;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = stdId_PRESENT;
	    	ret = StdId_Decode(&pVal->u.stdId, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = extId_PRESENT;
	    	ret = ExtId_Decode(&pVal->u.extId, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag Id_XER_Encode(const Id* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Id_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* CHOICE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "Id", NULL, pErrCode, 0);
	    if (ret) {
	        switch(pVal->kind) 
	        {
	            case stdId_PRESENT:
	            	ret = StdId_XER_Encode_aux(&pVal->u.stdId, "stdId", pByteStrm, pErrCode, FALSE);
	            	break;
	            case extId_PRESENT:
	            	ret = ExtId_XER_Encode_aux(&pVal->u.extId, "extId", pByteStrm, pErrCode, FALSE);
	            	break;
	            default:
	        	    *pErrCode = ERR_INVALID_XML_FILE;
	                ret = FALSE;
	        }
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, "Id", pErrCode, 0);
	        }
	    }
    }

	return ret;
}

flag Id_XER_Encode_aux(const Id* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Id_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* CHOICE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        switch(pVal->kind) 
	        {
	            case stdId_PRESENT:
	            	ret = StdId_XER_Encode_aux(&pVal->u.stdId, "stdId", pByteStrm, pErrCode, FALSE);
	            	break;
	            case extId_PRESENT:
	            	ret = ExtId_XER_Encode_aux(&pVal->u.extId, "extId", pByteStrm, pErrCode, FALSE);
	            	break;
	            default:
	        	    *pErrCode = ERR_INVALID_XML_FILE;
	                ret = FALSE;
	        }
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	        }
	    }
    }

	return ret;
}

flag Id_XER_Decode(Id* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* CHOICE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "Id", NULL, pErrCode);
	if (ret) {
	    {
	    	char nextTag[256];
	    	ret = Xer_LA_NextElementTag(pByteStrm, nextTag);
	    	if (ret) {
	    		if (strcmp(nextTag, "stdId") == 0) {
	    		    pVal->kind = stdId_PRESENT;
	    		    ret = StdId_XER_Decode_aux(&pVal->u.stdId, "stdId", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "extId") == 0) {
	    		    pVal->kind = extId_PRESENT;
	    		    ret = ExtId_XER_Decode_aux(&pVal->u.extId, "extId", pByteStrm, pErrCode);
	    		} 
	            else {
	                ret = FALSE;
	                *pErrCode = ERR_INVALID_XML_FILE;
	            }
	    	}
	    }
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, "Id", pErrCode);
	}

	return ret;
}

flag Id_XER_Decode_aux(Id* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* CHOICE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    {
	    	char nextTag[256];
	    	ret = Xer_LA_NextElementTag(pByteStrm, nextTag);
	    	if (ret) {
	    		if (strcmp(nextTag, "stdId") == 0) {
	    		    pVal->kind = stdId_PRESENT;
	    		    ret = StdId_XER_Decode_aux(&pVal->u.stdId, "stdId", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "extId") == 0) {
	    		    pVal->kind = extId_PRESENT;
	    		    ret = ExtId_XER_Decode_aux(&pVal->u.extId, "extId", pByteStrm, pErrCode);
	    		} 
	            else {
	                ret = FALSE;
	                *pErrCode = ERR_INVALID_XML_FILE;
	            }
	    	}
	    }
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void DLC_Initialize(DLC* pVal)
{
    *pVal = (DLC) 0;
}
#endif

 
flag DLC_IsConstraintValid(const DLC* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 8);
	*pErrCode = ret ? 0 : ERR_DLC;

	return ret;
}

flag DLC_Encode(const DLC* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DLC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 8);
    }

	return ret;
}

flag DLC_Decode(DLC* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 8);
	*pErrCode = ret ? 0 : 268435460;

	return ret;
}

flag DLC_XER_Encode(const DLC* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DLC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, "DLC", *pVal, pErrCode, 0);
    }

	return ret;
}

flag DLC_XER_Encode_aux(const DLC* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DLC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, xmlTag, *pVal, pErrCode, 0);
    }

	return ret;
}

flag DLC_XER_Decode(DLC* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, "DLC", pVal, pErrCode);

	return ret;
}

flag DLC_XER_Decode_aux(DLC* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, xmlTag, pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Data_Initialize(Data* pVal)
{
    *pVal = (Data) {0,
    {
    }
};
}
#endif

 
flag Data_IsConstraintValid(const Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= 8);
	*pErrCode = ret ? 0 : ERR_Data;

	return ret;
}

flag Data_Encode(const Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 8);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag Data_Decode(Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 8);
	*pErrCode = ret ? 0 : 268435461;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435462;
	}

	return ret;
}

flag Data_XER_Encode(const Data* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeOctetString(pByteStrm, "Data", pVal->arr, pVal->nCount, pErrCode, 0);
    }

	return ret;
}

flag Data_XER_Encode_aux(const Data* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeOctetString(pByteStrm, xmlTag, pVal->arr, pVal->nCount, pErrCode, 0);
    }

	return ret;
}

flag Data_XER_Decode(Data* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeOctetString(pByteStrm, "Data", pVal->arr, &pVal->nCount, pErrCode);

	return ret;
}

flag Data_XER_Decode_aux(Data* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeOctetString(pByteStrm, xmlTag, pVal->arr, &pVal->nCount, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RTR_Initialize(RTR* pVal)
{
    *pVal = (RTR) dataFrame;
}
#endif

 
flag RTR_IsConstraintValid(const RTR* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == dataFrame) || (*pVal == remoteRequestFrame));
	*pErrCode = ret ? 0 : ERR_RTR;

	return ret;
}

flag RTR_Encode(const RTR* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RTR_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case dataFrame:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case remoteRequestFrame:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag RTR_Decode(RTR* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435463;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = dataFrame;
	            break;
	        case 1: 
	            *pVal = remoteRequestFrame;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag RTR_XER_Encode(const RTR* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RTR_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case dataFrame:
	        	ret = Xer_EncodeEnumerated(pByteStrm, "RTR", "dataFrame", pErrCode, 0);
	        	break;
	        case remoteRequestFrame:
	        	ret = Xer_EncodeEnumerated(pByteStrm, "RTR", "remoteRequestFrame", pErrCode, 0);
	        	break;
	        default:
	    	    *pErrCode = ERR_INVALID_XML_FILE;
	    	    return FALSE;
	    }
    }

	return ret;
}

flag RTR_XER_Encode_aux(const RTR* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RTR_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case dataFrame:
	        	ret = Xer_EncodeEnumerated(pByteStrm, xmlTag, "dataFrame", pErrCode, 0);
	        	break;
	        case remoteRequestFrame:
	        	ret = Xer_EncodeEnumerated(pByteStrm, xmlTag, "remoteRequestFrame", pErrCode, 0);
	        	break;
	        default:
	    	    *pErrCode = ERR_INVALID_XML_FILE;
	    	    return FALSE;
	    }
    }

	return ret;
}

flag RTR_XER_Decode(RTR* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
		char enmLabel[200];
		ret = Xer_DecodeEnumerated(pByteStrm, "RTR", enmLabel, pErrCode);
	    if (ret) {
	        if(strcmp(enmLabel,"dataFrame") == 0)
	            *pVal = dataFrame;
	        else if(strcmp(enmLabel,"remoteRequestFrame") == 0)
	            *pVal = remoteRequestFrame;
		    else {
			    *pErrCode = ERR_INVALID_XML_FILE;
			    return FALSE;
		    }
	    }

	}

	return ret;
}

flag RTR_XER_Decode_aux(RTR* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
		char enmLabel[200];
		ret = Xer_DecodeEnumerated(pByteStrm, xmlTag, enmLabel, pErrCode);
	    if (ret) {
	        if(strcmp(enmLabel,"dataFrame") == 0)
	            *pVal = dataFrame;
	        else if(strcmp(enmLabel,"remoteRequestFrame") == 0)
	            *pVal = remoteRequestFrame;
		    else {
			    *pErrCode = ERR_INVALID_XML_FILE;
			    return FALSE;
		    }
	    }

	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void CANPacket20B_Initialize(CANPacket20B* pVal)
{
    *pVal = (CANPacket20B) {
    .id = {
        .kind = stdId_PRESENT,
        .u = { .stdId = 0}
    },
    .rtr = dataFrame,
    .res = FALSE,
    .dlc = 0,
    .data = {0,
        {
        }
    },
    .exist = {
        .res = 1
    }
};
}
#endif

 
flag CANPacket20B_IsConstraintValid(const CANPacket20B* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = Id_IsConstraintValid(&pVal->id, pErrCode);
	if (ret) {
	    ret = RTR_IsConstraintValid(&pVal->rtr, pErrCode);
	    if (ret) {
	        if (pVal->exist.res==1) {
	            ret = TRUE; *pErrCode = 0;
	        }
	        if (ret) {
	            ret = DLC_IsConstraintValid(&pVal->dlc, pErrCode);
	            if (ret) {
	                ret = Data_IsConstraintValid(&pVal->data, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag CANPacket20B_Encode(const CANPacket20B* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacket20B_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.res);
	    if (ret) {
	        /*Encode id */
	        ret = Id_Encode(&pVal->id, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rtr */
	            ret = RTR_Encode(&pVal->rtr, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode res */
	                if (pVal->exist.res) {
	                	BitStream_AppendBit(pBitStrm,pVal->res);
	                }
	                if (ret) {
	                    /*Encode dlc */
	                    ret = DLC_Encode(&pVal->dlc, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode data */
	                        ret = Data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	                    
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag CANPacket20B_Decode(CANPacket20B* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	unsigned char CANPacket20BbitMask[1];

	/* Decode Bit Mask for optional and default fields*/
	ret = BitStream_ReadBits(pBitStrm, CANPacket20BbitMask, 1);
	*pErrCode = ret ? 0 : 268435464;
	if (ret) {
	    if (ret) {
	        /*Decode id */
	        ret = Id_Decode(&pVal->id, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode rtr */
	            ret = RTR_Decode(&pVal->rtr, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode res */
	                {
	                    static flag defValue = FALSE;
	                    pVal->exist.res = 1;
	                    pVal->res = defValue;
	                    if ((CANPacket20BbitMask[0] & 0x80) != 0 ) {
	                	    ret = BitStream_ReadBit(pBitStrm, &pVal->res);
	                	    *pErrCode = ret ? 0 : 268435465;
	                    }
	                }
	                if (ret) {
	                    /*Decode dlc */
	                    ret = DLC_Decode(&pVal->dlc, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode data */
	                        ret = Data_Decode(&pVal->data, pBitStrm, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag CANPacket20B_XER_Encode(const CANPacket20B* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacket20B_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "CANPacket20B", NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode id */
	        ret = Id_XER_Encode_aux(&pVal->id, "id", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rtr */
	            ret = RTR_XER_Encode_aux(&pVal->rtr, "rtr", pByteStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode res */
	                if (pVal->exist.res) {
	                	ret = Xer_EncodeBoolean(pByteStrm, "res", pVal->res, pErrCode, 1);
	                }
	                if (ret) {
	                    /*Encode dlc */
	                    ret = DLC_XER_Encode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode data */
	                        ret = Data_XER_Encode_aux(&pVal->data, "data", pByteStrm, pErrCode, FALSE);
	                        if (ret) {
	                            ret = Xer_EncodeComplexElementEnd(pByteStrm, "CANPacket20B", pErrCode, 0);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag CANPacket20B_XER_Encode_aux(const CANPacket20B* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacket20B_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode id */
	        ret = Id_XER_Encode_aux(&pVal->id, "id", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rtr */
	            ret = RTR_XER_Encode_aux(&pVal->rtr, "rtr", pByteStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode res */
	                if (pVal->exist.res) {
	                	ret = Xer_EncodeBoolean(pByteStrm, "res", pVal->res, pErrCode, 1);
	                }
	                if (ret) {
	                    /*Encode dlc */
	                    ret = DLC_XER_Encode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode data */
	                        ret = Data_XER_Encode_aux(&pVal->data, "data", pByteStrm, pErrCode, FALSE);
	                        if (ret) {
	                            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag CANPacket20B_XER_Decode(CANPacket20B* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "CANPacket20B", NULL, pErrCode);
	if (ret) {
	    /*Decode id */
	    ret = Xer_NextStartElementIs(pByteStrm, "id");
	    if (ret) {
	    	ret = Id_XER_Decode_aux(&pVal->id, "id", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode rtr */
	        ret = Xer_NextStartElementIs(pByteStrm, "rtr");
	        if (ret) {
	        	ret = RTR_XER_Decode_aux(&pVal->rtr, "rtr", pByteStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode res */
	            pVal->exist.res = 0;
	            if (Xer_NextStartElementIs(pByteStrm, "res")) {
	            	pVal->exist.res = 1;
	            	ret = Xer_DecodeBoolean(pByteStrm, "res", &pVal->res, pErrCode);
	            }
	            if (ret) {
	                /*Decode dlc */
	                ret = Xer_NextStartElementIs(pByteStrm, "dlc");
	                if (ret) {
	                	ret = DLC_XER_Decode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode data */
	                    ret = Xer_NextStartElementIs(pByteStrm, "data");
	                    if (ret) {
	                    	ret = Data_XER_Decode_aux(&pVal->data, "data", pByteStrm, pErrCode);
	                    }
	                    if (ret) {
	                        ret = Xer_DecodeComplexElementEnd(pByteStrm, "CANPacket20B", pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag CANPacket20B_XER_Decode_aux(CANPacket20B* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    /*Decode id */
	    ret = Xer_NextStartElementIs(pByteStrm, "id");
	    if (ret) {
	    	ret = Id_XER_Decode_aux(&pVal->id, "id", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode rtr */
	        ret = Xer_NextStartElementIs(pByteStrm, "rtr");
	        if (ret) {
	        	ret = RTR_XER_Decode_aux(&pVal->rtr, "rtr", pByteStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode res */
	            pVal->exist.res = 0;
	            if (Xer_NextStartElementIs(pByteStrm, "res")) {
	            	pVal->exist.res = 1;
	            	ret = Xer_DecodeBoolean(pByteStrm, "res", &pVal->res, pErrCode);
	            }
	            if (ret) {
	                /*Decode dlc */
	                ret = Xer_NextStartElementIs(pByteStrm, "dlc");
	                if (ret) {
	                	ret = DLC_XER_Decode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode data */
	                    ret = Xer_NextStartElementIs(pByteStrm, "data");
	                    if (ret) {
	                    	ret = Data_XER_Decode_aux(&pVal->data, "data", pByteStrm, pErrCode);
	                    }
	                    if (ret) {
	                        ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void DLCFD_Initialize(DLCFD* pVal)
{
    *pVal = (DLCFD) 0;
}
#endif

 
flag DLCFD_IsConstraintValid(const DLCFD* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((((*pVal <= 8) || (*pVal == 12)) || (*pVal == 16)) || (*pVal == 20)) || (*pVal == 24)) || (*pVal == 32)) || (*pVal == 48)) || (*pVal == 64));
	*pErrCode = ret ? 0 : ERR_DLCFD;

	return ret;
}

flag DLCFD_Encode(const DLCFD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DLCFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 64);
    }

	return ret;
}

flag DLCFD_Decode(DLCFD* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 64);
	*pErrCode = ret ? 0 : 268435466;

	return ret;
}

flag DLCFD_XER_Encode(const DLCFD* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DLCFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, "DLCFD", *pVal, pErrCode, 0);
    }

	return ret;
}

flag DLCFD_XER_Encode_aux(const DLCFD* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DLCFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, xmlTag, *pVal, pErrCode, 0);
    }

	return ret;
}

flag DLCFD_XER_Decode(DLCFD* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, "DLCFD", pVal, pErrCode);

	return ret;
}

flag DLCFD_XER_Decode_aux(DLCFD* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, xmlTag, pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void DataFD_Initialize(DataFD* pVal)
{
    *pVal = (DataFD) {0,
    {
    }
};
}
#endif

 
flag DataFD_IsConstraintValid(const DataFD* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((((0 <= pVal->nCount && pVal->nCount <= 8) || (pVal->nCount == 12)) || (pVal->nCount == 16)) || (pVal->nCount == 20)) || (pVal->nCount == 24)) || (pVal->nCount == 32)) || (pVal->nCount == 48)) || (pVal->nCount == 64));
	*pErrCode = ret ? 0 : ERR_DataFD;

	return ret;
}

flag DataFD_Encode(const DataFD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? DataFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 64);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag DataFD_Decode(DataFD* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 64);
	*pErrCode = ret ? 0 : 268435467;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435468;
	}

	return ret;
}

flag DataFD_XER_Encode(const DataFD* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DataFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeOctetString(pByteStrm, "DataFD", pVal->arr, pVal->nCount, pErrCode, 0);
    }

	return ret;
}

flag DataFD_XER_Encode_aux(const DataFD* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DataFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeOctetString(pByteStrm, xmlTag, pVal->arr, pVal->nCount, pErrCode, 0);
    }

	return ret;
}

flag DataFD_XER_Decode(DataFD* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeOctetString(pByteStrm, "DataFD", pVal->arr, &pVal->nCount, pErrCode);

	return ret;
}

flag DataFD_XER_Decode_aux(DataFD* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeOctetString(pByteStrm, xmlTag, pVal->arr, &pVal->nCount, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void CANPacketFD_Initialize(CANPacketFD* pVal)
{
    *pVal = (CANPacketFD) {
    .id = {
        .kind = stdId_PRESENT,
        .u = { .stdId = 0}
    },
    .res = FALSE,
    .brs = FALSE,
    .esi = FALSE,
    .dlc = 0,
    .data = {0,
        {
        }
    },
    .exist = {
        .res = 1
    }
};
}
#endif

 
flag CANPacketFD_IsConstraintValid(const CANPacketFD* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = Id_IsConstraintValid(&pVal->id, pErrCode);
	if (ret) {
	    if (pVal->exist.res==1) {
	        ret = TRUE; *pErrCode = 0;
	    }
	    if (ret) {
	        ret = TRUE; *pErrCode = 0;
	        if (ret) {
	            ret = TRUE; *pErrCode = 0;
	            if (ret) {
	                ret = DLCFD_IsConstraintValid(&pVal->dlc, pErrCode);
	                if (ret) {
	                    ret = DataFD_IsConstraintValid(&pVal->data, pErrCode);
	                
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag CANPacketFD_Encode(const CANPacketFD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacketFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.res);
	    if (ret) {
	        /*Encode id */
	        ret = Id_Encode(&pVal->id, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode res */
	            if (pVal->exist.res) {
	            	BitStream_AppendBit(pBitStrm,pVal->res);
	            }
	            if (ret) {
	                /*Encode brs */
	                BitStream_AppendBit(pBitStrm,pVal->brs);
	                if (ret) {
	                    /*Encode esi */
	                    BitStream_AppendBit(pBitStrm,pVal->esi);
	                    if (ret) {
	                        /*Encode dlc */
	                        ret = DLCFD_Encode(&pVal->dlc, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode data */
	                            ret = DataFD_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag CANPacketFD_Decode(CANPacketFD* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	unsigned char CANPacketFDbitMask[1];

	/* Decode Bit Mask for optional and default fields*/
	ret = BitStream_ReadBits(pBitStrm, CANPacketFDbitMask, 1);
	*pErrCode = ret ? 0 : 268435469;
	if (ret) {
	    if (ret) {
	        /*Decode id */
	        ret = Id_Decode(&pVal->id, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode res */
	            {
	                static flag defValue = FALSE;
	                pVal->exist.res = 1;
	                pVal->res = defValue;
	                if ((CANPacketFDbitMask[0] & 0x80) != 0 ) {
	            	    ret = BitStream_ReadBit(pBitStrm, &pVal->res);
	            	    *pErrCode = ret ? 0 : 268435470;
	                }
	            }
	            if (ret) {
	                /*Decode brs */
	                ret = BitStream_ReadBit(pBitStrm, &pVal->brs);
	                *pErrCode = ret ? 0 : 268435471;
	                if (ret) {
	                    /*Decode esi */
	                    ret = BitStream_ReadBit(pBitStrm, &pVal->esi);
	                    *pErrCode = ret ? 0 : 268435472;
	                    if (ret) {
	                        /*Decode dlc */
	                        ret = DLCFD_Decode(&pVal->dlc, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            ret = DataFD_Decode(&pVal->data, pBitStrm, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag CANPacketFD_XER_Encode(const CANPacketFD* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacketFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "CANPacketFD", NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode id */
	        ret = Id_XER_Encode_aux(&pVal->id, "id", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode res */
	            if (pVal->exist.res) {
	            	ret = Xer_EncodeBoolean(pByteStrm, "res", pVal->res, pErrCode, 1);
	            }
	            if (ret) {
	                /*Encode brs */
	                ret = Xer_EncodeBoolean(pByteStrm, "brs", pVal->brs, pErrCode, 1);
	                if (ret) {
	                    /*Encode esi */
	                    ret = Xer_EncodeBoolean(pByteStrm, "esi", pVal->esi, pErrCode, 1);
	                    if (ret) {
	                        /*Encode dlc */
	                        ret = DLCFD_XER_Encode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode data */
	                            ret = DataFD_XER_Encode_aux(&pVal->data, "data", pByteStrm, pErrCode, FALSE);
	                            if (ret) {
	                                ret = Xer_EncodeComplexElementEnd(pByteStrm, "CANPacketFD", pErrCode, 0);
	                            
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag CANPacketFD_XER_Encode_aux(const CANPacketFD* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacketFD_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode id */
	        ret = Id_XER_Encode_aux(&pVal->id, "id", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode res */
	            if (pVal->exist.res) {
	            	ret = Xer_EncodeBoolean(pByteStrm, "res", pVal->res, pErrCode, 1);
	            }
	            if (ret) {
	                /*Encode brs */
	                ret = Xer_EncodeBoolean(pByteStrm, "brs", pVal->brs, pErrCode, 1);
	                if (ret) {
	                    /*Encode esi */
	                    ret = Xer_EncodeBoolean(pByteStrm, "esi", pVal->esi, pErrCode, 1);
	                    if (ret) {
	                        /*Encode dlc */
	                        ret = DLCFD_XER_Encode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode data */
	                            ret = DataFD_XER_Encode_aux(&pVal->data, "data", pByteStrm, pErrCode, FALSE);
	                            if (ret) {
	                                ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	                            
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag CANPacketFD_XER_Decode(CANPacketFD* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "CANPacketFD", NULL, pErrCode);
	if (ret) {
	    /*Decode id */
	    ret = Xer_NextStartElementIs(pByteStrm, "id");
	    if (ret) {
	    	ret = Id_XER_Decode_aux(&pVal->id, "id", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode res */
	        pVal->exist.res = 0;
	        if (Xer_NextStartElementIs(pByteStrm, "res")) {
	        	pVal->exist.res = 1;
	        	ret = Xer_DecodeBoolean(pByteStrm, "res", &pVal->res, pErrCode);
	        }
	        if (ret) {
	            /*Decode brs */
	            ret = Xer_NextStartElementIs(pByteStrm, "brs");
	            if (ret) {
	            	ret = Xer_DecodeBoolean(pByteStrm, "brs", &pVal->brs, pErrCode);
	            }
	            if (ret) {
	                /*Decode esi */
	                ret = Xer_NextStartElementIs(pByteStrm, "esi");
	                if (ret) {
	                	ret = Xer_DecodeBoolean(pByteStrm, "esi", &pVal->esi, pErrCode);
	                }
	                if (ret) {
	                    /*Decode dlc */
	                    ret = Xer_NextStartElementIs(pByteStrm, "dlc");
	                    if (ret) {
	                    	ret = DLCFD_XER_Decode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode data */
	                        ret = Xer_NextStartElementIs(pByteStrm, "data");
	                        if (ret) {
	                        	ret = DataFD_XER_Decode_aux(&pVal->data, "data", pByteStrm, pErrCode);
	                        }
	                        if (ret) {
	                            ret = Xer_DecodeComplexElementEnd(pByteStrm, "CANPacketFD", pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag CANPacketFD_XER_Decode_aux(CANPacketFD* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    /*Decode id */
	    ret = Xer_NextStartElementIs(pByteStrm, "id");
	    if (ret) {
	    	ret = Id_XER_Decode_aux(&pVal->id, "id", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode res */
	        pVal->exist.res = 0;
	        if (Xer_NextStartElementIs(pByteStrm, "res")) {
	        	pVal->exist.res = 1;
	        	ret = Xer_DecodeBoolean(pByteStrm, "res", &pVal->res, pErrCode);
	        }
	        if (ret) {
	            /*Decode brs */
	            ret = Xer_NextStartElementIs(pByteStrm, "brs");
	            if (ret) {
	            	ret = Xer_DecodeBoolean(pByteStrm, "brs", &pVal->brs, pErrCode);
	            }
	            if (ret) {
	                /*Decode esi */
	                ret = Xer_NextStartElementIs(pByteStrm, "esi");
	                if (ret) {
	                	ret = Xer_DecodeBoolean(pByteStrm, "esi", &pVal->esi, pErrCode);
	                }
	                if (ret) {
	                    /*Decode dlc */
	                    ret = Xer_NextStartElementIs(pByteStrm, "dlc");
	                    if (ret) {
	                    	ret = DLCFD_XER_Decode_aux(&pVal->dlc, "dlc", pByteStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode data */
	                        ret = Xer_NextStartElementIs(pByteStrm, "data");
	                        if (ret) {
	                        	ret = DataFD_XER_Decode_aux(&pVal->data, "data", pByteStrm, pErrCode);
	                        }
	                        if (ret) {
	                            ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void CANPacket_Initialize(CANPacket* pVal)
{
    *pVal = (CANPacket) {
    .kind = p20b_PRESENT,
    .u = { .p20b = {
    .id = {
        .kind = stdId_PRESENT,
        .u = { .stdId = 0}
    },
    .rtr = dataFrame,
    .res = FALSE,
    .dlc = 0,
    .data = {0,
        {
        }
    },
    .exist = {
        .res = 1
    }
}}
};
}
#endif

 
flag CANPacket_IsConstraintValid(const CANPacket* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case p20b_PRESENT :
	        ret = CANPacket20B_IsConstraintValid(&pVal->u.p20b, pErrCode);
	        break;
	    case pfd_PRESENT :
	        ret = CANPacketFD_IsConstraintValid(&pVal->u.pfd, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306372;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag CANPacket_Encode(const CANPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case p20b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = CANPacket20B_Encode(&pVal->u.p20b, pBitStrm, pErrCode, FALSE);
	    	break;
	    case pfd_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = CANPacketFD_Encode(&pVal->u.pfd, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306373;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag CANPacket_Decode(CANPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435473;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = p20b_PRESENT;
	    	ret = CANPacket20B_Decode(&pVal->u.p20b, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = pfd_PRESENT;
	    	ret = CANPacketFD_Decode(&pVal->u.pfd, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306374;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag CANPacket_XER_Encode(const CANPacket* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* CHOICE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "CANPacket", NULL, pErrCode, 0);
	    if (ret) {
	        switch(pVal->kind) 
	        {
	            case p20b_PRESENT:
	            	ret = CANPacket20B_XER_Encode_aux(&pVal->u.p20b, "p20b", pByteStrm, pErrCode, FALSE);
	            	break;
	            case pfd_PRESENT:
	            	ret = CANPacketFD_XER_Encode_aux(&pVal->u.pfd, "pfd", pByteStrm, pErrCode, FALSE);
	            	break;
	            default:
	        	    *pErrCode = ERR_INVALID_XML_FILE;
	                ret = FALSE;
	        }
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, "CANPacket", pErrCode, 0);
	        }
	    }
    }

	return ret;
}

flag CANPacket_XER_Encode_aux(const CANPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CANPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* CHOICE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        switch(pVal->kind) 
	        {
	            case p20b_PRESENT:
	            	ret = CANPacket20B_XER_Encode_aux(&pVal->u.p20b, "p20b", pByteStrm, pErrCode, FALSE);
	            	break;
	            case pfd_PRESENT:
	            	ret = CANPacketFD_XER_Encode_aux(&pVal->u.pfd, "pfd", pByteStrm, pErrCode, FALSE);
	            	break;
	            default:
	        	    *pErrCode = ERR_INVALID_XML_FILE;
	                ret = FALSE;
	        }
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	        }
	    }
    }

	return ret;
}

flag CANPacket_XER_Decode(CANPacket* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* CHOICE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "CANPacket", NULL, pErrCode);
	if (ret) {
	    {
	    	char nextTag[256];
	    	ret = Xer_LA_NextElementTag(pByteStrm, nextTag);
	    	if (ret) {
	    		if (strcmp(nextTag, "p20b") == 0) {
	    		    pVal->kind = p20b_PRESENT;
	    		    ret = CANPacket20B_XER_Decode_aux(&pVal->u.p20b, "p20b", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "pfd") == 0) {
	    		    pVal->kind = pfd_PRESENT;
	    		    ret = CANPacketFD_XER_Decode_aux(&pVal->u.pfd, "pfd", pByteStrm, pErrCode);
	    		} 
	            else {
	                ret = FALSE;
	                *pErrCode = ERR_INVALID_XML_FILE;
	            }
	    	}
	    }
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, "CANPacket", pErrCode);
	}

	return ret;
}

flag CANPacket_XER_Decode_aux(CANPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* CHOICE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    {
	    	char nextTag[256];
	    	ret = Xer_LA_NextElementTag(pByteStrm, nextTag);
	    	if (ret) {
	    		if (strcmp(nextTag, "p20b") == 0) {
	    		    pVal->kind = p20b_PRESENT;
	    		    ret = CANPacket20B_XER_Decode_aux(&pVal->u.p20b, "p20b", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "pfd") == 0) {
	    		    pVal->kind = pfd_PRESENT;
	    		    ret = CANPacketFD_XER_Decode_aux(&pVal->u.pfd, "pfd", pByteStrm, pErrCode);
	    		} 
	            else {
	                ret = FALSE;
	                *pErrCode = ERR_INVALID_XML_FILE;
	            }
	    	}
	    }
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	}

	return ret;
}

