/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "sm-1301_rpc.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void SendPacket_Initialize(SendPacket* pVal)
{
    *pVal = (SendPacket) {
    .packet = {
        .kind = p20b_PRESENT,
        .u = { .p20b = {
        .id = {
            .kind = stdId_PRESENT,
            .u = { .stdId = 0}
        },
        .rtr = dataFrame,
        .res = FALSE,
        .dlc = 0,
        .data = {0,
            {
            }
        },
        .exist = {
            .res = 1
        }
    }}
    }
};
}
#endif

 
flag SendPacket_IsConstraintValid(const SendPacket* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = CANPacket_IsConstraintValid(&pVal->packet, pErrCode);


	return ret;
}

flag SendPacket_Encode(const SendPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SendPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packet */
	    ret = CANPacket_Encode(&pVal->packet, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag SendPacket_Decode(SendPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode packet */
	ret = CANPacket_Decode(&pVal->packet, pBitStrm, pErrCode);
	


	return ret;
}

flag SendPacket_XER_Encode(const SendPacket* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SendPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "SendPacket", NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode packet */
	        ret = CANPacket_XER_Encode_aux(&pVal->packet, "packet", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, "SendPacket", pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag SendPacket_XER_Encode_aux(const SendPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SendPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode packet */
	        ret = CANPacket_XER_Encode_aux(&pVal->packet, "packet", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag SendPacket_XER_Decode(SendPacket* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "SendPacket", NULL, pErrCode);
	if (ret) {
	    /*Decode packet */
	    ret = Xer_NextStartElementIs(pByteStrm, "packet");
	    if (ret) {
	    	ret = CANPacket_XER_Decode_aux(&pVal->packet, "packet", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, "SendPacket", pErrCode);
	    
	    }
	}

	return ret;
}

flag SendPacket_XER_Decode_aux(SendPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    /*Decode packet */
	    ret = Xer_NextStartElementIs(pByteStrm, "packet");
	    if (ret) {
	    	ret = CANPacket_XER_Decode_aux(&pVal->packet, "packet", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Connect_Initialize(Connect* pVal)
{
    *pVal = (Connect) {

};
}
#endif

 
flag Connect_IsConstraintValid(const Connect* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;


	return ret;
}

flag Connect_Encode(const Connect* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Connect_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    }

	return ret;
}

flag Connect_Decode(Connect* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;


	return ret;
}

flag Connect_XER_Encode(const Connect* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Connect_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "Connect", NULL, pErrCode, 0);
	    if (ret) {
	        ret = Xer_EncodeComplexElementEnd(pByteStrm, "Connect", pErrCode, 0);
	    
	    }
    }

	return ret;
}

flag Connect_XER_Encode_aux(const Connect* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Connect_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	    
	    }
    }

	return ret;
}

flag Connect_XER_Decode(Connect* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "Connect", NULL, pErrCode);
	if (ret) {
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, "Connect", pErrCode);
	
	}

	return ret;
}

flag Connect_XER_Decode_aux(Connect* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Disconnect_Initialize(Disconnect* pVal)
{
    *pVal = (Disconnect) {

};
}
#endif

 
flag Disconnect_IsConstraintValid(const Disconnect* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;


	return ret;
}

flag Disconnect_Encode(const Disconnect* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Disconnect_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    }

	return ret;
}

flag Disconnect_Decode(Disconnect* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;


	return ret;
}

flag Disconnect_XER_Encode(const Disconnect* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Disconnect_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "Disconnect", NULL, pErrCode, 0);
	    if (ret) {
	        ret = Xer_EncodeComplexElementEnd(pByteStrm, "Disconnect", pErrCode, 0);
	    
	    }
    }

	return ret;
}

flag Disconnect_XER_Encode_aux(const Disconnect* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Disconnect_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	    
	    }
    }

	return ret;
}

flag Disconnect_XER_Decode(Disconnect* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "Disconnect", NULL, pErrCode);
	if (ret) {
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, "Disconnect", pErrCode);
	
	}

	return ret;
}

flag Disconnect_XER_Decode_aux(Disconnect* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Response_Initialize(Response* pVal)
{
    *pVal = (Response) ok;
}
#endif

 
flag Response_IsConstraintValid(const Response* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == ok) || (*pVal == error));
	*pErrCode = ret ? 0 : ERR_Response;

	return ret;
}

flag Response_Encode(const Response* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Response_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case ok:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = 1074003969; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag Response_Decode(Response* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	*pErrCode = ret ? 0 : 268697601;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = ok;
	            break;
	        case 1: 
	            *pVal = error;
	            break;
	        default:
		        *pErrCode = 1074003970;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag Response_XER_Encode(const Response* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Response_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case ok:
	        	ret = Xer_EncodeEnumerated(pByteStrm, "Response", "ok", pErrCode, 0);
	        	break;
	        case error:
	        	ret = Xer_EncodeEnumerated(pByteStrm, "Response", "error", pErrCode, 0);
	        	break;
	        default:
	    	    *pErrCode = ERR_INVALID_XML_FILE;
	    	    return FALSE;
	    }
    }

	return ret;
}

flag Response_XER_Encode_aux(const Response* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Response_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case ok:
	        	ret = Xer_EncodeEnumerated(pByteStrm, xmlTag, "ok", pErrCode, 0);
	        	break;
	        case error:
	        	ret = Xer_EncodeEnumerated(pByteStrm, xmlTag, "error", pErrCode, 0);
	        	break;
	        default:
	    	    *pErrCode = ERR_INVALID_XML_FILE;
	    	    return FALSE;
	    }
    }

	return ret;
}

flag Response_XER_Decode(Response* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
		char enmLabel[200];
		ret = Xer_DecodeEnumerated(pByteStrm, "Response", enmLabel, pErrCode);
	    if (ret) {
	        if(strcmp(enmLabel,"ok") == 0)
	            *pVal = ok;
	        else if(strcmp(enmLabel,"error") == 0)
	            *pVal = error;
		    else {
			    *pErrCode = ERR_INVALID_XML_FILE;
			    return FALSE;
		    }
	    }

	}

	return ret;
}

flag Response_XER_Decode_aux(Response* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
		char enmLabel[200];
		ret = Xer_DecodeEnumerated(pByteStrm, xmlTag, enmLabel, pErrCode);
	    if (ret) {
	        if(strcmp(enmLabel,"ok") == 0)
	            *pVal = ok;
	        else if(strcmp(enmLabel,"error") == 0)
	            *pVal = error;
		    else {
			    *pErrCode = ERR_INVALID_XML_FILE;
			    return FALSE;
		    }
	    }

	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RespPacket_Initialize(RespPacket* pVal)
{
    *pVal = (RespPacket) {
    .resp = ok
};
}
#endif

 
flag RespPacket_IsConstraintValid(const RespPacket* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = Response_IsConstraintValid(&pVal->resp, pErrCode);


	return ret;
}

flag RespPacket_Encode(const RespPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RespPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode resp */
	    ret = Response_Encode(&pVal->resp, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag RespPacket_Decode(RespPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode resp */
	ret = Response_Decode(&pVal->resp, pBitStrm, pErrCode);
	


	return ret;
}

flag RespPacket_XER_Encode(const RespPacket* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RespPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "RespPacket", NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode resp */
	        ret = Response_XER_Encode_aux(&pVal->resp, "resp", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, "RespPacket", pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag RespPacket_XER_Encode_aux(const RespPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RespPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode resp */
	        ret = Response_XER_Encode_aux(&pVal->resp, "resp", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag RespPacket_XER_Decode(RespPacket* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "RespPacket", NULL, pErrCode);
	if (ret) {
	    /*Decode resp */
	    ret = Xer_NextStartElementIs(pByteStrm, "resp");
	    if (ret) {
	    	ret = Response_XER_Decode_aux(&pVal->resp, "resp", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, "RespPacket", pErrCode);
	    
	    }
	}

	return ret;
}

flag RespPacket_XER_Decode_aux(RespPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    /*Decode resp */
	    ret = Xer_NextStartElementIs(pByteStrm, "resp");
	    if (ret) {
	    	ret = Response_XER_Decode_aux(&pVal->resp, "resp", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void SetBitRate_bitRate_Initialize(SetBitRate_bitRate* pVal)
{
    *pVal = (SetBitRate_bitRate) 0;
}
#endif

 
flag SetBitRate_bitRate_IsConstraintValid(const SetBitRate_bitRate* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 1000000);
	*pErrCode = ret ? 0 : ERR_SetBitRate_bitRate;

	return ret;
}

flag SetBitRate_bitRate_Encode(const SetBitRate_bitRate* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SetBitRate_bitRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 1000000);
    }

	return ret;
}

flag SetBitRate_bitRate_Decode(SetBitRate_bitRate* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1000000);
	*pErrCode = ret ? 0 : 268697602;

	return ret;
}

flag SetBitRate_bitRate_XER_Encode(const SetBitRate_bitRate* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SetBitRate_bitRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, "SetBitRate-bitRate", *pVal, pErrCode, 0);
    }

	return ret;
}

flag SetBitRate_bitRate_XER_Encode_aux(const SetBitRate_bitRate* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SetBitRate_bitRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = Xer_EncodeInteger(pByteStrm, xmlTag, *pVal, pErrCode, 0);
    }

	return ret;
}

flag SetBitRate_bitRate_XER_Decode(SetBitRate_bitRate* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, "SetBitRate-bitRate", pVal, pErrCode);

	return ret;
}

flag SetBitRate_bitRate_XER_Decode_aux(SetBitRate_bitRate* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = Xer_DecodeInteger(pByteStrm, xmlTag, pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void SetBitRate_Initialize(SetBitRate* pVal)
{
    *pVal = (SetBitRate) {
    .bitRate = 0
};
}
#endif

 
flag SetBitRate_IsConstraintValid(const SetBitRate* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = SetBitRate_bitRate_IsConstraintValid(&pVal->bitRate, pErrCode);


	return ret;
}

flag SetBitRate_Encode(const SetBitRate* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SetBitRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bitRate */
	    ret = SetBitRate_bitRate_Encode(&pVal->bitRate, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag SetBitRate_Decode(SetBitRate* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode bitRate */
	ret = SetBitRate_bitRate_Decode(&pVal->bitRate, pBitStrm, pErrCode);
	


	return ret;
}

flag SetBitRate_XER_Encode(const SetBitRate* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SetBitRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "SetBitRate", NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode bitRate */
	        ret = SetBitRate_bitRate_XER_Encode_aux(&pVal->bitRate, "bitRate", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, "SetBitRate", pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag SetBitRate_XER_Encode_aux(const SetBitRate* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SetBitRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode bitRate */
	        ret = SetBitRate_bitRate_XER_Encode_aux(&pVal->bitRate, "bitRate", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag SetBitRate_XER_Decode(SetBitRate* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "SetBitRate", NULL, pErrCode);
	if (ret) {
	    /*Decode bitRate */
	    ret = Xer_NextStartElementIs(pByteStrm, "bitRate");
	    if (ret) {
	    	ret = SetBitRate_bitRate_XER_Decode_aux(&pVal->bitRate, "bitRate", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, "SetBitRate", pErrCode);
	    
	    }
	}

	return ret;
}

flag SetBitRate_XER_Decode_aux(SetBitRate* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    /*Decode bitRate */
	    ret = Xer_NextStartElementIs(pByteStrm, "bitRate");
	    if (ret) {
	    	ret = SetBitRate_bitRate_XER_Decode_aux(&pVal->bitRate, "bitRate", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Command_Initialize(Command* pVal)
{
    *pVal = (Command) {
    .kind = connect_PRESENT,
    .u = { .connect = {

}}
};
}
#endif

 
flag Command_IsConstraintValid(const Command* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case connect_PRESENT :
	        ret = Connect_IsConstraintValid(&pVal->u.connect, pErrCode);
	        break;
	    case disconnect_PRESENT :
	        ret = Disconnect_IsConstraintValid(&pVal->u.disconnect, pErrCode);
	        break;
	    case sbr_PRESENT :
	        ret = SetBitRate_IsConstraintValid(&pVal->u.sbr, pErrCode);
	        break;
	    case sp_PRESENT :
	        ret = SendPacket_IsConstraintValid(&pVal->u.sp, pErrCode);
	        break;
	    default:
		    *pErrCode = 805568513;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag Command_Encode(const Command* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Command_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case connect_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = Connect_Encode(&pVal->u.connect, pBitStrm, pErrCode, FALSE);
	    	break;
	    case disconnect_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = Disconnect_Encode(&pVal->u.disconnect, pBitStrm, pErrCode, FALSE);
	    	break;
	    case sbr_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = SetBitRate_Encode(&pVal->u.sbr, pBitStrm, pErrCode, FALSE);
	    	break;
	    case sp_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = SendPacket_Encode(&pVal->u.sp, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805568514;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag Command_Decode(Command* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 3);
	*pErrCode = ret ? 0 : 268697603;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = connect_PRESENT;
	    	ret = Connect_Decode(&pVal->u.connect, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = disconnect_PRESENT;
	    	ret = Disconnect_Decode(&pVal->u.disconnect, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = sbr_PRESENT;
	    	ret = SetBitRate_Decode(&pVal->u.sbr, pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = sp_PRESENT;
	    	ret = SendPacket_Decode(&pVal->u.sp, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805568515;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag Command_XER_Encode(const Command* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Command_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* CHOICE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "Command", NULL, pErrCode, 0);
	    if (ret) {
	        switch(pVal->kind) 
	        {
	            case connect_PRESENT:
	            	ret = Connect_XER_Encode_aux(&pVal->u.connect, "connect", pByteStrm, pErrCode, FALSE);
	            	break;
	            case disconnect_PRESENT:
	            	ret = Disconnect_XER_Encode_aux(&pVal->u.disconnect, "disconnect", pByteStrm, pErrCode, FALSE);
	            	break;
	            case sbr_PRESENT:
	            	ret = SetBitRate_XER_Encode_aux(&pVal->u.sbr, "sbr", pByteStrm, pErrCode, FALSE);
	            	break;
	            case sp_PRESENT:
	            	ret = SendPacket_XER_Encode_aux(&pVal->u.sp, "sp", pByteStrm, pErrCode, FALSE);
	            	break;
	            default:
	        	    *pErrCode = ERR_INVALID_XML_FILE;
	                ret = FALSE;
	        }
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, "Command", pErrCode, 0);
	        }
	    }
    }

	return ret;
}

flag Command_XER_Encode_aux(const Command* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Command_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* CHOICE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        switch(pVal->kind) 
	        {
	            case connect_PRESENT:
	            	ret = Connect_XER_Encode_aux(&pVal->u.connect, "connect", pByteStrm, pErrCode, FALSE);
	            	break;
	            case disconnect_PRESENT:
	            	ret = Disconnect_XER_Encode_aux(&pVal->u.disconnect, "disconnect", pByteStrm, pErrCode, FALSE);
	            	break;
	            case sbr_PRESENT:
	            	ret = SetBitRate_XER_Encode_aux(&pVal->u.sbr, "sbr", pByteStrm, pErrCode, FALSE);
	            	break;
	            case sp_PRESENT:
	            	ret = SendPacket_XER_Encode_aux(&pVal->u.sp, "sp", pByteStrm, pErrCode, FALSE);
	            	break;
	            default:
	        	    *pErrCode = ERR_INVALID_XML_FILE;
	                ret = FALSE;
	        }
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	        }
	    }
    }

	return ret;
}

flag Command_XER_Decode(Command* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* CHOICE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "Command", NULL, pErrCode);
	if (ret) {
	    {
	    	char nextTag[256];
	    	ret = Xer_LA_NextElementTag(pByteStrm, nextTag);
	    	if (ret) {
	    		if (strcmp(nextTag, "connect") == 0) {
	    		    pVal->kind = connect_PRESENT;
	    		    ret = Connect_XER_Decode_aux(&pVal->u.connect, "connect", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "disconnect") == 0) {
	    		    pVal->kind = disconnect_PRESENT;
	    		    ret = Disconnect_XER_Decode_aux(&pVal->u.disconnect, "disconnect", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "sbr") == 0) {
	    		    pVal->kind = sbr_PRESENT;
	    		    ret = SetBitRate_XER_Decode_aux(&pVal->u.sbr, "sbr", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "sp") == 0) {
	    		    pVal->kind = sp_PRESENT;
	    		    ret = SendPacket_XER_Decode_aux(&pVal->u.sp, "sp", pByteStrm, pErrCode);
	    		} 
	            else {
	                ret = FALSE;
	                *pErrCode = ERR_INVALID_XML_FILE;
	            }
	    	}
	    }
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, "Command", pErrCode);
	}

	return ret;
}

flag Command_XER_Decode_aux(Command* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* CHOICE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    {
	    	char nextTag[256];
	    	ret = Xer_LA_NextElementTag(pByteStrm, nextTag);
	    	if (ret) {
	    		if (strcmp(nextTag, "connect") == 0) {
	    		    pVal->kind = connect_PRESENT;
	    		    ret = Connect_XER_Decode_aux(&pVal->u.connect, "connect", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "disconnect") == 0) {
	    		    pVal->kind = disconnect_PRESENT;
	    		    ret = Disconnect_XER_Decode_aux(&pVal->u.disconnect, "disconnect", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "sbr") == 0) {
	    		    pVal->kind = sbr_PRESENT;
	    		    ret = SetBitRate_XER_Decode_aux(&pVal->u.sbr, "sbr", pByteStrm, pErrCode);
	    		}
	    		else if (strcmp(nextTag, "sp") == 0) {
	    		    pVal->kind = sp_PRESENT;
	    		    ret = SendPacket_XER_Decode_aux(&pVal->u.sp, "sp", pByteStrm, pErrCode);
	    		} 
	            else {
	                ret = FALSE;
	                *pErrCode = ERR_INVALID_XML_FILE;
	            }
	    	}
	    }
	    ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void CmdPacket_Initialize(CmdPacket* pVal)
{
    *pVal = (CmdPacket) {
    .cmd = {
        .kind = connect_PRESENT,
        .u = { .connect = {

    }}
    }
};
}
#endif

 
flag CmdPacket_IsConstraintValid(const CmdPacket* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = Command_IsConstraintValid(&pVal->cmd, pErrCode);


	return ret;
}

flag CmdPacket_Encode(const CmdPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CmdPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode cmd */
	    ret = Command_Encode(&pVal->cmd, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag CmdPacket_Decode(CmdPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode cmd */
	ret = Command_Decode(&pVal->cmd, pBitStrm, pErrCode);
	


	return ret;
}

flag CmdPacket_XER_Encode(const CmdPacket* pVal, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CmdPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, "CmdPacket", NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode cmd */
	        ret = Command_XER_Encode_aux(&pVal->cmd, "cmd", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, "CmdPacket", pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag CmdPacket_XER_Encode_aux(const CmdPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CmdPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* SEQUENCE Encode*/
	    ret = Xer_EncodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode, 0);
	    if (ret) {
	        /*Encode cmd */
	        ret = Command_XER_Encode_aux(&pVal->cmd, "cmd", pByteStrm, pErrCode, FALSE);
	        if (ret) {
	            ret = Xer_EncodeComplexElementEnd(pByteStrm, xmlTag, pErrCode, 0);
	        
	        }
	    }
    }

	return ret;
}

flag CmdPacket_XER_Decode(CmdPacket* pVal, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, "CmdPacket", NULL, pErrCode);
	if (ret) {
	    /*Decode cmd */
	    ret = Xer_NextStartElementIs(pByteStrm, "cmd");
	    if (ret) {
	    	ret = Command_XER_Decode_aux(&pVal->cmd, "cmd", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, "CmdPacket", pErrCode);
	    
	    }
	}

	return ret;
}

flag CmdPacket_XER_Decode_aux(CmdPacket* pVal, const char* xmlTag, ByteStream* pByteStrm, int* pErrCode)
{
    flag ret = TRUE;

	/* SEQUENCE Decode*/
	ret = Xer_DecodeComplexElementStart(pByteStrm, xmlTag, NULL, pErrCode);
	if (ret) {
	    /*Decode cmd */
	    ret = Xer_NextStartElementIs(pByteStrm, "cmd");
	    if (ret) {
	    	ret = Command_XER_Decode_aux(&pVal->cmd, "cmd", pByteStrm, pErrCode);
	    }
	    if (ret) {
	        ret = Xer_DecodeComplexElementEnd(pByteStrm, xmlTag, pErrCode);
	    
	    }
	}

	return ret;
}

